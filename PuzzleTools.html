<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ·±é«˜åˆ›æ–°â€¢å­¦ç”Ÿä¹‰å·¥æ‹¼å›¾å·¥å…· v1.0.6.2511</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
  <style>
    /* ä¸Šé¢çš„CSSä»£ç æ”¾åœ¨è¿™é‡Œ */
    #downloadProgressBar { width: 0%; }
    #loadingBar { width: 0%; }
    #domWatermark { display: none; }
  </style>
    <style>
/* * ===================================================
 * ğŸ¨ ä¸»é¢˜é¢œè‰²ç®¡ç†
 * =================================================== */
:root {
    --color-primary: 10, 132, 255;
    --color-primary-dark: 0, 105, 250;
    --color-secondary: 220, 220, 225;
    --color-secondary-dark: 209, 213, 219;
    --color-body-bg: 247, 247, 250; 
    --shadow-apple-soft: 0 1px 3px rgba(0, 0, 0, 0.08); 
    --shadow-card: 0 4px 12px rgba(0, 0, 0, 0.04); 
    --mobile-padding: 0.5rem;
    --mobile-btn-padding: 8px 12px;
    --mobile-font-sm: 0.875rem;
    --mobile-font-base: 1rem;
    --control-gap: 0.5rem; /* 12pxï¼Œå››ä¸ªå…ƒç´ ç»Ÿä¸€é—´è· */
    --control-gap-sm: 0.25rem; /* 8pxï¼Œç§»åŠ¨ç«¯ç»Ÿä¸€é—´è· */
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Arial, sans-serif;
    background-color: rgb(var(--color-body-bg));
    background-image: none;
    transition: background-color 0.3s ease;
    min-height: 100vh;
}

/* åŸºç¡€æ ·å¼å·¥å…·ç±» */
.shadow-apple { box-shadow: var(--shadow-card); }
.bg-primary { background-color: rgb(var(--color-primary)); }
.hover\:bg-primary-dark:hover { background-color: rgb(var(--color-primary-dark)); }
.text-primary { color: rgb(var(--color-primary)); }
.border-primary { border-color: rgb(var(--color-primary)); }
.focus\:border-primary:focus { border-color: rgb(var(--color-primary)); }
.bg-secondary { background-color: rgb(var(--color-secondary)); }
.hover\:bg-secondary-dark:hover { background-color: rgb(var(--color-secondary-dark)); }

/* ===================================================
 * åŸºç¡€ç»„ä»¶æ ·å¼
 * =================================================== */
.rect-container { 
    position: relative; 
    overflow: hidden; 
    background-color: #ffffff; 
    cursor: default; 
}
.rect-item { position: absolute; overflow: hidden; display: flex; justify-content: center; align-items: center; background-color: transparent; cursor: pointer; }
.rect-item img { width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease; }
.rect-item:hover img { transform: scale(1.05); }
.fade-in { animation: fadeIn 0.5s ease-out; }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

/* ğŸš€ DOM æ°´å°å±‚æ ·å¼ */
#domWatermark {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 50; 
    font-weight: bold;
    text-align: center;
    -webkit-text-stroke: 1px rgba(255, 255, 255, 0.9);
    text-stroke: 1px rgba(255, 255, 255, 0.9);
    color: rgba(var(--color-primary), 0.9); 
    opacity: 0.9;
    pointer-events: none; 
    user-select: none;
}

/* ===================================================
 * æ§åˆ¶æ å¸ƒå±€ä¼˜åŒ–
 * =================================================== */
.controls-bar {
    display: flex;
    align-items: center; /* å‚ç›´å±…ä¸­ */
    justify-content: center; /* æ•´ä½“å±…ä¸­ */
    gap: 4px !important;
    box-sizing: border-box;
    padding: var(--control-gap-sm) 0 !important; /* æ¸…é™¤å·¦å³paddingï¼Œé¿å…çˆ¶å®¹å™¨å®½åº¦è¢«å‹ç¼© */
    width: 100% !important;
    max-width: 100% !important;
}

.controls-bar .stats-group,
.controls-bar .actions-group {
    display: flex;
    align-items: center;
    flex-wrap: nowrap;
    gap: var(--control-gap);
}

#leftControls, #rightControls {
    display: flex;
    align-items: center;
    gap: var(--control-gap);
    width: auto;
}

.controls-bar > * {
    margin: 0 !important; /* æ¸…é™¤æ‰€æœ‰å­å…ƒç´ è‡ªå¸¦margin */
    flex-shrink: 0; /* é˜²æ­¢å…ƒç´ è¢«æŒ¤å‹å˜å½¢ */
}

/* å³ä¾§æ“ä½œåŒºä¸“é¡¹ä¼˜åŒ– */
#rightControls {
    justify-content: flex-end;
    padding: 0;
    margin: 0;
}

#rightControls > * {
    margin: 0 !important;
    flex-shrink: 0;
}

#rightControls .route-input-base {
    min-height: 34px;
    width: 130px !important; /* è¦†ç›–é€šç”¨æ ·å¼ */
}

#rightControls .primary-capsule-btn {
    min-height: 34px;
    padding: 6px 18px;
}

/* ===================================================
 * æŒ‰é’®å’Œè¾“å…¥æ¡†æ ·å¼ 
 * =================================================== */
/* åŸºç¡€æŒ‰é’®æ ·å¼ï¼ˆç»Ÿä¸€ç»§æ‰¿å±æ€§ï¼‰ */
.btn-base {
    font-family: inherit;
    transition: all 0.3s ease-out;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    cursor: pointer;
}
.btn-base:disabled {
    cursor: not-allowed;
    opacity: 1;
    transform: none;
    box-shadow: none;
}

/* 1. ä¸»æŒ‰é’®ï¼ˆé€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼‰ */
.primary-btn { 
    @apply btn-base;
    font-weight: 600; 
    border-radius: 1rem; 
    padding: 12px 20px; 
    color: white; 
    background-color: rgb(var(--color-primary)); 
    box-shadow: 0 4px 10px rgba(var(--color-primary), 0.3); 
    border: none; 
}
@media (min-width: 640px) { 
    .primary-btn { 
        font-size: 1.875rem; 
        padding: 15px 25px;
    } 
    .controls-bar { flex-wrap: nowrap; }
}
@media (max-width: 639px) {
    .primary-btn { 
        font-size: 1.5rem; 
        padding: 10px 16px;
    }
}
.primary-btn:disabled { 
    background-color: rgb(var(--color-secondary-dark)); 
    color: #9ca3af; 
}
.primary-btn:hover:not(:disabled) { 
    background-color: rgb(var(--color-primary-dark)); 
    box-shadow: 0 6px 15px rgba(var(--color-primary-dark), 0.4); 
    transform: translateY(-1px); 
}
.primary-btn:active:not(:disabled) { 
    background-color: rgb(var(--color-primary-dark)); 
    box-shadow: 0 2px 5px rgba(var(--color-primary), 0.2); 
    transform: translateY(0); 
}

/* 2. èƒ¶å›Šä¸»æŒ‰é’®ï¼ˆæ·»åŠ å›¾ç‰‡/ä¸‹è½½æ‹¼å›¾ï¼‰ */
.primary-capsule-btn { 
    @apply btn-base;
    font-weight: 600;
    border-radius: 12px; 
    font-size: 18px; 
    padding: 6px 16px; 
    min-height: 34px; 
    color: white; 
    background-image: linear-gradient(to top, rgb(var(--color-primary-dark)) 0%, rgb(var(--color-primary)) 100%); 
    box-shadow: 0 2px 8px rgba(var(--color-primary), 0.4); 
}
.primary-capsule-btn:disabled { 
    background-color: rgb(var(--color-secondary-dark)); 
    background-image: none; 
    color: #9ca3af; 
}

/* 3. æ¬¡è¦æŒ‰é’®åŸºç¡€æ ·å¼ */
.secondary-btn { 
    @apply btn-base;
    font-weight: 600;
    font-size: 16px; 
    padding: 6px 12px; 
    min-height: 34px; 
    color: rgb(var(--color-primary)); 
    background: white; 
    border: 2px solid rgb(var(--color-secondary)); 
    box-shadow: var(--shadow-apple-soft); 
    border-radius: 8px; 
    gap: 4px;
    margin: 0;
}
.secondary-btn:hover:not(:disabled) { 
    background-color: rgb(var(--color-body-bg)); 
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); 
}

/* 4. æ“ä½œæŒ‰é’®ï¼ˆä¸»é¢˜/åˆ·æ–°/æ¸…ç©ºï¼‰ */
.rect-action-btn {
    @apply secondary-btn;
    padding: 4px 8px;
}
.rect-action-btn i {
    font-size: 2rem !important;
}

/* 5. å¸ƒå±€/æ¸…æ™°åº¦é€‰æ‹©å™¨æŒ‰é’® */
.ratio-quality-btn {
    @apply secondary-btn;
    padding: 4px 12px;
    border: 2px solid rgb(var(--color-secondary));
    border-left: none;
    border-radius: 0;
    font-size: 14px; 
}
.ratio-quality-btn:first-of-type {
    border-left: 2px solid rgb(var(--color-secondary));
    border-top-left-radius: 9999px;
    border-bottom-left-radius: 9999px;
}
.ratio-quality-btn:last-of-type {
    border-top-right-radius: 9999px;
    border-bottom-right-radius: 9999px;
}
.ratio-quality-btn.active {
    @apply primary-capsule-btn;
    background-image: linear-gradient(to top, rgb(var(--color-primary-dark)) 0%, rgb(var(--color-primary)) 100%);
    padding: 4px 12px;
    border: 2px solid rgb(var(--color-primary));
    color: white;
    box-shadow: 0 2px 8px rgba(var(--color-primary), 0.4);
    z-index: 1;
    margin: 0;
}
.ratio-quality-btn.active:first-of-type {
    border-top-left-radius: 9999px;
    border-bottom-left-radius: 9999px;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
}
.ratio-quality-btn.active:last-of-type {
    border-top-right-radius: 9999px;
    border-bottom-right-radius: 9999px;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
}
.ratio-quality-btn.active:not(:first-of-type):not(:last-of-type) {
    border-radius: 0;
}
.ratio-quality-btn.active:only-child {
    border-radius: 9999px;
}
.ratio-quality-btn.active ~ .ratio-quality-btn:not(.active) { 
    border-left: 2px solid rgb(var(--color-secondary));
}

.route-input-base { 
    width: 130px !important;
    max-width: 120px;
    min-height: 34px;
    padding: 6px 8px !important; /* å¢åŠ å·¦å³å†…è¾¹è·ï¼Œä¼˜åŒ–è¾“å…¥ä½“éªŒ */
    border: 2px solid rgb(var(--color-secondary));
    border-radius: 12px;
    font-size: 0.8rem !important; /* ä»2remæ”¹ä¸º1.2remï¼Œé€‚é…è¾“å…¥æ¡†é«˜åº¦ */
    text-align: center;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
    vertical-align: middle;
    line-height: 1.2;
    resize: none; /* ç¦æ­¢æ‹‰ä¼¸ï¼Œé¿å…é«˜åº¦å¼‚å¸¸ */
    box-sizing: border-box;
    transition: all 0.15s ease;
    outline: none;
}
.route-input-base:focus { 
    border-color: rgb(var(--color-primary)); 
    box-shadow: 0 0 0 3px rgba(var(--color-primary), 0.3), inset 0 1px 2px rgba(0, 0, 0, 0.05); 
}
.route-input-base::-webkit-input-placeholder,
.route-input-base:-ms-input-placeholder,
.route-input-base::placeholder { 
    text-align: center; 
    color: #9ca3af; 
    line-height: inherit;
    vertical-align: middle;
}

/* 7. åŠ¨ç”»ä¸é”™è¯¯æ ·å¼ */
.animate-pulse-primary { 
    animation: pulse-primary 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; 
}
@keyframes pulse-primary { 
    0%, 100% { box-shadow: 0 0 0 0 rgba(var(--color-primary), 0.7); } 
    50% { box-shadow: 0 0 0 8px rgba(var(--color-primary), 0); } 
}
.border-error { border-color: rgb(var(--color-primary)); }

/* 8. å›¾æ ‡æŒ‰é’®ä¸“ç”¨æ ·å¼ */
.icon-btn {
    @apply primary-capsule-btn;
    border-radius: 8px;
    padding: 8px 12px;
    min-width: 44px;
}

/* 9. é¡¶éƒ¨æ·»åŠ å›¾ç‰‡æŒ‰é’® */
#fileInputTopLabel.primary-capsule-btn {
    padding: 6px 16px;
}

/* 10. ä¸‹è½½æŒ‰é’®ç»Ÿä¸€æ ·å¼ */
#downloadBtn.primary-capsule-btn,
#rightControls #downloadBtn.primary-capsule-btn {
    padding: 6px 18px;
    box-shadow: 0 2px 8px rgba(var(--color-primary), 0.4);
    min-width: auto;
}

/* ===================================================
 * ç§»åŠ¨ç«¯é€‚é…ï¼ˆåˆå¹¶æ‰€æœ‰å°å±å¹•æ ·å¼ï¼‰
 * =================================================== */
@media (max-width: 640px) {
    /* å®¹å™¨å®½åº¦è°ƒæ•´ */
    .w-full.max-w-\[66\.6666\%\] {
        max-width: 96% !important;
    }
    
    #imageContainerParent {
        max-width: 100% !important; /* å æ»¡æ‰‹æœºå±å¹•å®½åº¦ */
        padding: 2px !important; /* å‡å°‘å†…è¾¹è·ï¼Œé¿å…ç•™ç™½ */
        min-height: 300px !important; /* ç©ºçŠ¶æ€é»˜è®¤é«˜åº¦ */
        display: flex !important; /* ç©ºçŠ¶æ€å†…å®¹å±…ä¸­ */
        align-items: center !important;
        justify-content: center !important;
    }
    
    .rect-container {
        width: 100% !important; /* æ‹¼å›¾å®¹å™¨å®½åº¦è‡ªé€‚åº” */
    }
    
    /* æ¨¡æ€æ¡†è°ƒæ•´ */
    #imageModal > div {
        max-width: 96% !important;
        max-height: 95vh !important;
    }
    
    .p-4 {
        padding: 0.75rem !important;
    }
    
    #modalImage {
        max-height: 60vh !important;
    }
    
    .flex-wrap > div {
        width: 100% !important;
        justify-content: center !important;
        margin-bottom: 0.5rem !important;
    }
    
    /* æ“ä½œæŒ‰é’®è°ƒæ•´ */
    .rect-action-btn {
        padding: 5px 10px !important;
    }
    
    .rect-action-btn i {
        font-size: 0.9rem !important;
    }
    
    /* è¾“å…¥æ¡†åŸºç¡€æ ·å¼ */
    .route-input-base {
        width: 100px !important;
        margin: 0 !important;
    }
    
    /* ä¸‹è½½æŒ‰é’®è°ƒæ•´ */
    #rightControls #downloadBtn.primary-capsule-btn {
        border-radius: 1rem !important;
        padding: 4px 8px !important;
        min-width: 36px !important;
    }
    
/* ==============================================
 * æ ¸å¿ƒï¼šæ§åˆ¶æ ï¼ˆæ•°é‡/åƒç´ /å¸ƒå±€/æ¸…æ™°åº¦ï¼‰æ ·å¼
 * ============================================== */
/* 1. æ§åˆ¶æ æ•´ä½“å®¹å™¨ */
.controls-bar {
    padding: var(--control-gap-sm) 4px !important; /* å‡å°‘å·¦å³ç•™ç™½ */
    gap: 5px !important; /* ç¼©å°æ§åˆ¶æ å·¦å³åŒºåŸŸé—´è· */
}

/* 2. å·¦ä¾§æ ¸å¿ƒå†…å®¹åŒºçˆ¶å®¹å™¨ï¼ˆå·²æ•´åˆå¯¹é½æ ¸å¿ƒè§„åˆ™ï¼‰ */
.controls-bar .stats-row {
    display: flex !important;
    flex-wrap: nowrap !important; /* ä¸æ¢è¡Œ */
    align-items: center !important; /* æ‰€æœ‰å­å…ƒç´ å‚ç›´å±…ä¸­ï¼ˆæ ¸å¿ƒï¼‰ */
    line-height: 1.2 !important; /* ç»Ÿä¸€è¡Œé«˜ï¼Œé¿å…æ–‡å­—/æŒ‰é’®é«˜ä½ä¸ä¸€ */
    justify-content: flex-start !important; /* å·¦å¯¹é½ */
    width: 100% !important; /* æ‹‰æ»¡å®½åº¦ */
    max-width: 100% !important;
    overflow-x: auto !important; /* è¶…å®½æ¨ªå‘æ»šåŠ¨ */
    overflow-y: hidden !important; /* ç¦æ­¢å‚ç›´æ»šåŠ¨ */
    padding: 2px 0 !important;
    margin: 0 !important;
    gap: 5px !important; /* ç»Ÿä¸€å­å…ƒç´ é—´è·ï¼ˆæ•°é‡/åƒç´ /å¸ƒå±€ä¹‹é—´ï¼‰ */
    scrollbar-width: thin !important; /* ç»†æ»šåŠ¨æ¡ */
}

/* æ»šåŠ¨æ¡æ ·å¼ */
.controls-bar .stats-row::-webkit-scrollbar {
    height: 4px !important;
}
.controls-bar .stats-row::-webkit-scrollbar-thumb {
    background-color: rgba(0,0,0,0.1) !important;
    border-radius: 2px !important;
}

/* 3. å­å…ƒç´ ç»Ÿä¸€å¤„ç†ï¼ˆæ¸…é™¤å‚ç›´å¹²æ‰°+å¯¹é½ç»§æ‰¿ï¼‰ */
.stats-row > * {
    margin: 0 !important;
    padding: 0 !important;
    flex-shrink: 0 !important; /* ä¸è¢«æŒ¤å‹ */
    line-height: inherit !important; /* ç»§æ‰¿çˆ¶å®¹å™¨è¡Œé«˜ï¼Œé¿å…æ–‡å­—åç§» */
    vertical-align: middle !important; /* å…¼å®¹inlineå…ƒç´ å¯¹é½ */
}

/* æ–°å¢ï¼šå•ç‹¬ç¼©å°â€œå¸ƒå±€â€å’Œâ€œæ¸…æ™°åº¦â€ä¹‹é—´çš„é—´è· */
.stats-row > div + div {
    margin-left: 2px !important; /* æ¯”å…¶ä»–å…ƒç´ é—´è·å°ï¼Œç¡®ä¿ç´§å‡‘ */
}

/* 4. æ•°é‡/åƒç´ æ–‡æœ¬æ ·å¼ï¼ˆç¡®ä¿ä¸æŒ‰é’®å¯¹é½ï¼‰ */
.controls-bar .stats-row p {
    white-space: nowrap !important; /* ä¸æ¢è¡Œ */
    font-size: 11px !important;
    padding: 2px 0 !important;
    line-height: 1.2 !important; /* ä¸æŒ‰é’®è¡Œé«˜åŒ¹é… */
    height: auto !important; /* æ¸…é™¤å›ºå®šé«˜åº¦ï¼Œé¿å…æŒ¤å‹ */
    align-self: center !important; /* å¼ºåˆ¶å‚ç›´å±…ä¸­ï¼Œä¼˜å…ˆçº§æœ€é«˜ */
}

/* æ•°é‡/åƒç´ ä¸­çš„æ•°å­—æ ·å¼ */
.controls-bar .stats-row p #imageCount,
.controls-bar .stats-row p #rectDimensions {
    font-size: 11px !important; /* ä¸æ–‡å­—åŒå°ºå¯¸ï¼Œä¸çªå‡º */
}

/* 5. å¸ƒå±€/æ¸…æ™°åº¦åˆ†ç»„å®¹å™¨ï¼ˆä¸æ–‡æœ¬å¯¹é½ï¼‰ */
.controls-bar .stats-row > div {
    padding: 2px 0 !important;
    width: auto !important; /* å®½åº¦éšå†…å®¹å˜åŒ–ï¼Œä¸å¼ºåˆ¶å›ºå®š */
    height: auto !important; /* æ¸…é™¤å›ºå®šé«˜åº¦ */
    align-self: center !important; /* å¼ºåˆ¶å‚ç›´å±…ä¸­ï¼Œä¸pæ ‡ç­¾å¯¹é½ */
}

/* 6. å¸ƒå±€/æ¸…æ™°åº¦æ–‡å­—æ ·å¼ */
.stats-row span {
    white-space: nowrap !important;
    font-size: 11px !important;
    margin-right: 2px !important; /* æ–‡å­—ä¸æŒ‰é’®é—´éš™ */
}

/* 7. å¸ƒå±€/æ¸…æ™°åº¦æŒ‰é’®æ ·å¼ï¼ˆåŒ¹é…æ–‡æœ¬é«˜åº¦ï¼‰ */
.ratio-quality-btn {
    min-width: 28px !important; /* å›ºå®šå®½åº¦ï¼Œç¡®ä¿èƒ½æ”¾ä¸‹æ–‡å­— */
    white-space: nowrap !important; /* æŒ‰é’®æ–‡å­—ä¸æ¢è¡Œ */
    font-size: 10px !important; /* ç¼©å°æ–‡å­—ï¼Œçœç©ºé—´ */
    padding: 2px 4px !important; /* å‹ç¼©å†…è¾¹è·ï¼Œå‡å°‘æ¨ªå‘å ç”¨ */
    line-height: 1.2 !important; /* ä¸pæ ‡ç­¾è¡Œé«˜ä¸€è‡´ï¼Œé¿å…ä¸Šä¸‹åç§» */
    height: auto !important; /* æ¸…é™¤å›ºå®šé«˜åº¦ï¼Œç”±å†…å®¹å†³å®š */
    border: 2px solid rgb(var(--color-secondary)) !important;
}

/* ä¿®æ­£ï¼šé€‰ä¸­æŒ‰é’®æ ·å¼ï¼ˆåŸç±»åå¤šå†™ä¸€ä¸ª"quality"ï¼Œå·²ä¿®æ­£ï¼‰ */
.ratio-quality-btn.active {
    background-image: linear-gradient(to top, rgb(var(--color-primary-dark)) 0%, rgb(var(--color-primary)) 100%) !important;
    border-color: rgb(var(--color-primary)) !important;
    color: white !important;
}

/* ==============================================
 * å³ä¾§æ“ä½œåŒºæ ·å¼
 * ============================================== */
#leftControls, #rightControls {
    gap: var(--control-gap-sm);
    width: 100%;
    justify-content: center;
}

#rightControls {
    margin-top: var(--control-gap-sm) !important;
    gap: 4px !important; /* ç¼©å°è¾“å…¥æ¡†ä¸ä¸‹è½½æŒ‰é’®é—´è· */
}

#rightControls .route-input-base {
    width: 120px !important;
}

#rightControls .primary-capsule-btn {
    padding: 4px 12px !important;
}

/* ç»Ÿä¸€æŒ‰é’®æ–‡æœ¬å¤§å° */
.primary-capsule-btn {
    font-size: 16px !important;
}

/* é¡µé¢é«˜åº¦åŸºç¡€æ ·å¼ */
html, body {
    height: 100%; /* å æ»¡å±å¹•é«˜åº¦ */
}

footer {
    height: 60px !important; /* å›ºå®šç‰ˆæƒåŒºé«˜åº¦ */
}

/* è¯­å½•å®¹å™¨åŠçˆ¶å…ƒç´ å¼ºåˆ¶å¯è§ */
#quoteWrapper,
#quoteWrapper > div,
#currentQuote {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: relative !important;
  z-index: 100 !important; /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ï¼Œä¸è¢«é®æŒ¡ */
  height: auto !important;
  overflow: visible !important;
}

/* è¯­å½•æ–‡å­—æ ·å¼ï¼ˆç¡®ä¿èƒ½çœ‹æ¸…ï¼‰ */
#currentQuote {
  color: #555 !important; /* æ·±ç°è‰²ï¼Œé¿å…ä¸èƒŒæ™¯èåˆ */
  font-size: 16px !important;
  padding: 10px 0 !important;
  margin: 0 !important;
  text-align: center !important;
  line-height: 1.5 !important;
}
     
    </style>
</head>
<body class="min-h-screen flex flex-col">
    
    <div class="w-full sticky top-0 z-10 max-w-[66.6666%] mx-auto">
        <header class="bg-white shadow-apple rounded-xl border-b border-gray-100 w-full">
            <div class="px-3 pt-3 pb-2 w-full"> 
                <div class="w-full flex justify-between items-center flex-wrap gap-2"> 
                    
                    <div class="flex items-end flex-wrap"> 
                        <h1 class="text-xl sm:text-3xl font-black text-primary tracking-wide mr-3 m-0">
                            <span class="hidden sm:inline">æ·±é«˜åˆ›æ–°â€¢å­¦ç”Ÿä¹‰å·¥æ‹¼å›¾å·¥å…·</span>
                            <span class="sm:hidden">åˆ›æ–°â€¢ä¹‰å·¥æ‹¼å›¾å·¥å…·</span>
                        </h1>
                        <span class="text-sm sm:text-base text-gray-500 font-medium">v1.0.6.2511</span>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                    
                        <button id="themeSwitchBtn" class="secondary-btn">
                            <i class="fa fa-palette"></i> <span class="hidden sm:inline">ä¸»é¢˜</span>
                        </button>                   
                        <button id="regenerateBtn" class="secondary-btn">
                            <i class="fa fa-sync-alt"></i> <span class="hidden sm:inline">é‡æ’</span>
                        </button>
                        <button id="clearBtn" class="secondary-btn">
                            <i class="fa fa-trash"></i> <span class="hidden sm:inline">æ¸…ç©º</span>
                        </button>
                   
                   
                        <input type="file" id="fileInputTop" multiple accept="image/jpeg,image/png,image/webp" class="hidden">
                        <label for="fileInputTop" id="fileInputTopLabel" class="cursor-pointer primary-capsule-btn">
                            <i class="fa fa-upload"></i> <span class="hidden sm:inline">æ·»åŠ å›¾ç‰‡</span>
                        </label>
                    </div>
                </div>
            </div>
        </header>
    </div>

    <main class="flex-grow pb-4"> 
        
<div id="statsBar" class="bg-white p-1 rounded-2xl shadow-apple w-full max-w-[66.6666%] mx-auto flex flex-col gap-1 mt-1 hidden">          
<div class="controls-bar flex flex-wrap justify-between items-center gap-x-2 gap-y-1">  
    <div class="stats-row flex items-baseline flex-nowrap gap-x-2 gap-y-0.5 w-full sm:w-auto">
                 
        <!-- å¸ƒå±€é€‰æ‹©å™¨ - ç§»åŠ¨ç«¯ç¼©å°å°ºå¯¸ -->
<div class="flex items-center flex-wrap gap-0 w-full sm:w-auto mt-0 sm:mt-0">
    <span class="font-semibold text-gray-700 mr-1 text-xs sm:text-lg">å¸ƒå±€</span>
    <!-- æ–°å¢ radio è¾“å…¥æ¡† -->
    <input type="radio" name="aspectRatio" id="ratio-16-9" value="16:9" class="hidden">
    <label for="ratio-16-9" class="ratio-quality-btn cursor-pointer text-xs" data-value="16:9" data-group="aspectRatio">16:9</label>
    
    <input type="radio" name="aspectRatio" id="ratio-4-3" value="4:3" class="hidden" checked>
    <label for="ratio-4-3" class="ratio-quality-btn cursor-pointer text-xs" data-value="4:3" data-group="aspectRatio">4:3</label>						
    
    <input type="radio" name="aspectRatio" id="ratio-1-1" value="1:1" class="hidden">
    <label for="ratio-1-1" class="ratio-quality-btn cursor-pointer text-xs" data-value="1:1" data-group="aspectRatio">1:1</label>
</div>

        <!-- æ¸…æ™°åº¦é€‰æ‹©å™¨ - ç§»åŠ¨ç«¯ç¼©å°å°ºå¯¸ -->
<div class="flex items-center flex-wrap gap-0 w-full sm:w-auto mt-0 sm:mt-0">
    <span class="font-semibold text-gray-700 mr-1 text-xs sm:text-lg">æ¸…æ™°åº¦</span>
    <!-- æ–°å¢ radio è¾“å…¥æ¡† -->
    <input type="radio" name="renderQuality" id="quality-1x" value="1" class="hidden">
    <label for="quality-1x" class="ratio-quality-btn cursor-pointer text-xs" data-value="1" data-group="renderQuality">1x</label>
    
    <input type="radio" name="renderQuality" id="quality-2x" value="2" class="hidden" checked> <!-- é»˜è®¤é€‰ä¸­2x -->
    <label for="quality-2x" class="ratio-quality-btn cursor-pointer text-xs" data-value="2" data-group="renderQuality">2x</label>
    
    <input type="radio" name="renderQuality" id="quality-3x" value="3" class="hidden">
    <label for="quality-3x" class="ratio-quality-btn cursor-pointer text-xs" data-value="3" data-group="renderQuality">3x</label>
</div>
    </div>
   
    <!-- å³ä¾§æ“ä½œæŒ‰é’® - ç§»åŠ¨ç«¯å †å  -->   
    <div class="flex items-center flex-wrap gap-x-2 gap-y-0 sm:w-auto w-full justify-between sm:justify-end">
                    


        <div id="rightControls" class="flex items-center w-full sm:w-auto mt-0 sm:mt-0">
    <textarea id="routeNumberInput" placeholder="è¯·è¾“å…¥çº¿è·¯ç¼–å·" maxlength="130" rows="1" class="route-input-base text-xs"></textarea>
    <button id="downloadBtn" class="primary-capsule-btn text-xs">
        <i class="fa fa-download"></i> <!-- å§‹ç»ˆæ˜¾ç¤ºå›¾æ ‡ -->
        <span class="hidden sm:inline">ä¸‹è½½</span> <!-- æ‰‹æœºç«¯éšè—æ–‡å­—ï¼Œsmä»¥ä¸Šæ˜¾ç¤º -->
    </button>
        </div>
    </div>
</div>
</div>
        
<div id="imageContainerParent" class="flex justify-center items-center bg-white p-2 sm:p-4 rounded-2xl shadow-apple relative w-full max-w-[66.6666%] mx-auto mt-1.5 min-h-[200px] sm:min-h-80">
    <!-- ä¸‹è½½é®ç½©ï¼ˆä¿ç•™ï¼‰ -->
    <div id="downloadOverlay" class="hidden absolute inset-0 bg-white/90 backdrop-blur-sm z-20 rounded-2xl flex-col justify-center items-center p-8 text-center space-y-4">
        <p class="text-base sm:text-2xl font-semibold text-primary">æ­£åœ¨ä½¿ç”¨ç”Ÿæˆå¤§å›¾...</p> 
        <p class="text-base sm:text-lg font-semibold text-gray-700">è¯·è€å¿ƒç­‰å¾… 5-15 ç§’ã€‚è‹¥å¤±è´¥ï¼Œè¯·åˆ‡æ¢æ¸…æ™°åº¦!</p>
        <div class="w-full max-w-sm bg-gray-200 rounded-full h-2.5">
            <div id="downloadProgressBar" class="bg-primary h-2.5 rounded-full transition-all duration-100 ease-linear"></div>
        </div>
        <p id="downloadProgressText" class="text-base text-gray-500">æ­£åœ¨ç­‰å¾…æµè§ˆå™¨æ¸²æŸ“...</p>
    </div>

    <!-- ä¿®å¤ï¼šç©ºçŠ¶æ€å®¹å™¨ï¼ˆåˆ é™¤é‡å¤åµŒå¥—ï¼Œç¡®ä¿é—­åˆï¼‰ -->
    <div id="emptyState" class="text-center py-20 px-8 space-y-6 flex flex-col items-center w-full">
        <svg class="mx-auto h-20 w-20 text-primary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-12 5h12a2 2 0 002-2V7a2 2 0 00-2-2H6a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
        </svg>
        <p class="text-2xl sm:text-3xl font-black text-gray-800">æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„ä¸Šä¼ </p>
        <p class="text-lg text-gray-500">ï¼ˆæ”¯æŒå¤šå¼ å›¾ç‰‡åŒæ—¶ä¸Šä¼ ï¼Œæ–‡ä»¶æ ¼å¼ï¼šJPEG/PNG/WEBPï¼‰</p>
        <input type="file" id="fileInput" multiple accept="image/jpeg,image/png,image/webp" class="hidden">
        <label for="fileInput" id="emptyStateUploadLabel" class="cursor-pointer primary-btn rounded-full">
            <i class="fa fa-upload sm:hidden"></i>
            <span class="hidden sm:inline">é€‰æ‹©å›¾ç‰‡æ–‡ä»¶</span>
        </label>
    </div>

    <!-- åŠ è½½çŠ¶æ€ï¼ˆä¿ç•™ï¼‰ -->
    <div id="loadingState" class="hidden absolute inset-0 bg-white/90 z-10 flex flex-col justify-center items-center p-8 text-center space-y-4 rounded-2xl">
        <i class="fa fa-spinner fa-spin text-4xl text-primary"></i>
        <p id="loadingText" class="text-lg font-semibold text-gray-700 text-base sm:text-lg">æ­£åœ¨åŠ è½½å¹¶è½¬æ¢å›¾ç‰‡ä»¥ç¡®ä¿æ°´å°å®‰å…¨...</p>
        <div class="w-full max-w-sm bg-gray-200 rounded-full h-2.5">
            <div id="loadingBar" class="bg-primary h-2.5 rounded-full transition-all duration-300 ease-out"></div>
        </div>
    </div>

    <!-- æ‹¼å›¾å®¹å™¨ï¼ˆä¿ç•™ï¼‰ -->
    <div id="rectContainer" class="rect-container shadow-inner border-2 border-gray-200 rounded-lg">
        <div id="domWatermark" class="text-4xl"></div>
    </div>
</div>
        
        <div class="w-full max-w-[66.6666%] mx-auto mt-1.5">
             <div class="text-center bg-white rounded-xl shadow-apple italic w-full">
                <p id="currentQuote" class="transition-opacity duration-1000 opacity-100 p-4 text-sm sm:text-base text-gray-500"></p>
            </div>
        </div>

    </main>

    <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-80 backdrop-blur-md hidden flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog">
        <div class="relative bg-white rounded-2xl w-full max-w-screen-xl max-h-[90vh] flex flex-col shadow-apple">
            <div class="p-4 border-b flex justify-between items-center bg-gray-50/50 rounded-t-2xl">
                <h3 id="imageName" class="text-lg sm:text-xl font-bold truncate">å›¾ç‰‡å</h3>
                <button id="closeModal" class="secondary-btn p-2 rounded-full text-gray-500 hover:text-gray-800 transition" title="å…³é—­é¢„è§ˆ"><i class="fa fa-times text-base"></i></button>
            </div>
            <div class="relative flex-grow overflow-hidden flex items-center justify-center p-4">
                <img id="modalImage" src="" alt="Preview" class="object-contain max-h-full max-w-full">
            </div>
            <div class="p-4 border-t flex justify-between items-center flex-wrap space-y-2 sm:space-y-0 text-sm sm:text-base bg-gray-50/50 rounded-b-2xl">
                <div class="flex items-center space-x-4 text-gray-600">
                    <p>å°ºå¯¸: <span id="modalImgSize" class="font-semibold"></span></p>
                    <p>æ¯”ä¾‹: <span id="modalImgRatio" class="font-semibold"></span></p>
                </div>
                <div class="flex items-center space-x-3">
                    <button id="downloadSingleBtn" class="text-primary hover:text-primary-dark font-semibold transition"><i class="fa fa-download mr-1"></i> å•å¼ ä¸‹è½½</button>
                    <button id="deleteSingleBtn" class="text-primary hover:text-primary-dark font-semibold transition"><i class="fa fa-trash mr-1"></i> åˆ é™¤</button>
                </div>
                
                <div class="flex items-center space-x-4 ml-auto sm:ml-0 mt-2 sm:mt-0">
                    <button id="prevImageBtn" class="secondary-btn p-2 rounded-full disabled:opacity-50 transition" title="æŸ¥çœ‹ä¸Šä¸€å¼ å›¾ç‰‡"><i class="fa fa-arrow-left"></i></button>
                    <span class="font-bold text-gray-700"><span id="currentImageIndex">1</span> / <span id="totalImageCount">1</span></span>
                    <button id="nextImageBtn" class="secondary-btn p-2 rounded-full disabled:opacity-50 transition" title="æŸ¥çœ‹ä¸‹ä¸€å¼ å›¾ç‰‡"><i class="fa fa-arrow-right"></i></button>
                </div>
            </div>
        </div>
    </div>

    <footer class="p-3 text-center text-sm text-gray-500">
        <p id="copyrightFooter"></p>
    </footer>

    <script>
        
        // * ===================================================
        // * ğŸ¨ ä¸»é¢˜åˆ‡æ¢é€»è¾‘ (ä¿æŒä¸å˜)
        // * ===================================================
        const THEMES = [
            { name: 'Blue (è‹¹æœ)', primary: '10, 132, 255', dark: '0, 105, 250' },
            { name: 'Red (ç»å…¸)', primary: '220, 38, 38', dark: '185, 28, 28' },
            { name: 'Green (è‡ªç„¶)', primary: '22, 163, 74', dark: '21, 128, 61' },
            { name: 'Purple (åˆ›æ–°)', primary: '124, 58, 237', dark: '109, 40, 217' }
        ];
        let currentThemeIndex = 0;
        const root = document.documentElement;

        function applyTheme(theme) {
            root.style.setProperty('--color-primary', theme.primary);
            root.style.setProperty('--color-primary-dark', theme.dark);
        }

        function switchTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
            const nextTheme = THEMES[currentThemeIndex];
            applyTheme(nextTheme);
            localStorage.setItem('themeIndex', currentThemeIndex);
        }

        function loadTheme() {
            const savedIndex = localStorage.getItem('themeIndex');
            if (savedIndex !== null && !isNaN(parseInt(savedIndex)) && parseInt(savedIndex) >= 0 && parseInt(savedIndex) < THEMES.length) {
                currentThemeIndex = parseInt(savedIndex);
            }
            applyTheme(THEMES[currentThemeIndex]);
        }
        
        // ğŸš€ æ ¸å¿ƒå‡½æ•°ï¼šè·å–å½“å‰çš„ç¼©æ”¾æ¯”ä¾‹ (1, 2, æˆ– 3)
        function getScale() {
            const radio = document.querySelector('input[name="renderQuality"]:checked');
            // é»˜è®¤å€¼ï¼š2x
            return radio ? parseInt(radio.value) : 2; 
        }


        document.addEventListener('DOMContentLoaded', function() {
            loadTheme();
            
            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            class GalleryOptimizer {
                
                CONFIG = {
                    GAP: 1,
                    IDEAL_ROW_HEIGHT: 250, 
                    BINARY_SEARCH_ITERATIONS: 15, 
                    JPEG_QUALITY: 1.0, 
                };

                constructor() {
                    this.dom = this._getDomReferences();
                    this.state = this._getInitialState();
                    
                    this._initEventListeners();
                    this._setupDragAndDrop();
                    // ç¡®ä¿åœ¨åˆå§‹åŒ–æ—¶æ›´æ–°æŒ‰é’®çŠ¶æ€
                    this.updateRatioButtonState(this.state.aspectRatio, 'aspectRatio');
                    this.updateRatioButtonState(this.state.renderQuality.toString(), 'renderQuality');
                    this.updateUIState();
                }

                _getDomReferences() {
                    const ids = [
                        'rectContainer', 'fileInput', 'fileInputTop', 'fileInputTopLabel', 
                        'emptyState', 'loadingState', 'loadingText', 'loadingBar', 'downloadBtn',
                        'clearBtn', 'imageModal', 'modalImage', 'closeModal', 'prevImageBtn',
                        'nextImageBtn', 'currentImageIndex', 'totalImageCount', 'emptyStateUploadLabel',
                        'statsBar', 'rectDimensions', 'regenerateBtn', 'imageName',
                        'downloadSingleBtn', 'deleteSingleBtn', 'modalImgSize',
                        'modalImgRatio', 'routeNumberInput', 'downloadOverlay', 
                        'downloadProgressBar', 'downloadProgressText', 'imageCount',
                        'themeSwitchBtn', 'rightControls', 'imageContainerParent', 'currentQuote',
                        'domWatermark' 
                    ];
                    const dom = {};
                    ids.forEach(id => dom[id] = document.getElementById(id));
                    dom.aspectRatioRadios = document.querySelectorAll('input[name="aspectRatio"]');
                    dom.renderQualityRadios = document.querySelectorAll('input[name="renderQuality"]');
                    dom.ratioButtons = document.querySelectorAll('.ratio-quality-btn'); 
                    return dom;
                }

                _getInitialState() {
                    let defaultRatio = '4:3';
                    const checkedRatio = document.querySelector('input[name="aspectRatio"]:checked');
                    if(checkedRatio) defaultRatio = checkedRatio.value;
                    
                    // é»˜è®¤å€¼ï¼š2x
                    let defaultQuality = 2;
                    const checkedQuality = document.querySelector('input[name="renderQuality"]:checked');
                    if(checkedQuality) defaultQuality = parseInt(checkedQuality.value);

                    return {
                        imageItems: [],
                        currentPreviewIndex: 0,
                        isDownloading: false,
                        rectWidth: 0,
                        layoutPositions: [],
                        totalHeight: 0,
                        aspectRatio: defaultRatio,
                        renderQuality: defaultQuality,
                    };
                }

                _initEventListeners() {
                    this.dom.fileInput.addEventListener('change', (e) => this.handleFileUpload(e.target.files));
                    this.dom.fileInputTop.addEventListener('change', (e) => this.handleFileUpload(e.target.files));
                    
                    this.dom.downloadBtn.addEventListener('click', this.downloadRectangle.bind(this));
                    this.dom.clearBtn.addEventListener('click', this.clearAllImages.bind(this));
                    this.dom.regenerateBtn.addEventListener('click', this.regenerateLayout.bind(this));
                    this.dom.closeModal.addEventListener('click', this.closeModal.bind(this));
                    this.dom.prevImageBtn.addEventListener('click', () => this.switchPreviewImage(-1));
                    this.dom.nextImageBtn.addEventListener('click', () => this.switchPreviewImage(1));
                    this.dom.imageModal.addEventListener('click', (e) => { if (e.target === this.dom.imageModal) this.closeModal(); });
                    this.dom.downloadSingleBtn.addEventListener('click', () => this.downloadSingleImage());
                    this.dom.deleteSingleBtn.addEventListener('click', () => this.deleteCurrentImage());
                    this.dom.themeSwitchBtn.addEventListener('click', switchTheme); 

                    document.addEventListener('keydown', (e) => {
                        if (this.dom.imageModal.classList.contains('hidden')) return;
                        if (e.key === 'Escape') this.closeModal();
                        if (e.key === 'ArrowLeft') this.switchPreviewImage(-1);
                        if (e.key === 'ArrowRight') this.switchPreviewImage(1);
                    });
                    
                    this.dom.routeNumberInput.addEventListener('input', () => this.handleRouteInputChange());
                    
                    this.dom.aspectRatioRadios.forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            this.state.aspectRatio = e.target.value;
                            this.updateRatioButtonState(e.target.value, 'aspectRatio'); 
                            this.calculateAndRenderRectangle();
                        });
                    });
                    
                    this.dom.renderQualityRadios.forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            this.state.renderQuality = parseInt(e.target.value);
                            this.updateRatioButtonState(e.target.value, 'renderQuality'); 
                        });
                    });

                    window.addEventListener('resize', debounce(this.calculateAndRenderRectangle.bind(this), 150));
                    
                    if (this.state.imageItems.length === 0) {
                        this.dom.imageContainerParent.classList.remove('hidden');
                        this.dom.emptyState.classList.remove('hidden');
                    }
                }
                
                handleRouteInputChange() {
                    this.updateUIState();
                    this._updateWatermarkVisibility();
                }

_updateWatermarkVisibility() {
    const watermarkText = this.dom.routeNumberInput.value.trim();
    let rectWidth = this.state.rectWidth;
    const domWatermark = this.dom.domWatermark;

    // è‹¥rectWidthæ— æ•ˆï¼Œä»DOMè·å–æˆ–ç”¨ä¿åº•å€¼
    if (!rectWidth || rectWidth < 100) {
        rectWidth = this.dom.rectContainer.getBoundingClientRect().width || 200;
    }
const maxWatermarkWidth = rectWidth * 0.9; // 4/5çš„é¢„è§ˆåŒºåŸŸå®½åº¦
    if (watermarkText !== '' && rectWidth > 0) {
        domWatermark.textContent = watermarkText;
        domWatermark.style.whiteSpace = 'pre-line';
        domWatermark.style.lineHeight = '1.2';
        domWatermark.style.wordBreak = 'break-word'; // å…³é”®ï¼šé¿å…å­—æ¯/æ•°å­—è¢«å¼ºåˆ¶æ‹†åˆ†
        domWatermark.style.wordSpacing = '0'; // æ¶ˆé™¤é¢å¤–å­—é—´è·å½±å“
domWatermark.style.maxWidth = `${maxWatermarkWidth}px`; // å¼ºåˆ¶æ°´å°ä¸è¶…è¿‡4/5å®½åº¦
        domWatermark.style.margin = '0 auto'; // å±…ä¸­æ˜¾ç¤ºï¼ˆå¯é€‰ï¼Œæ›´ç¾è§‚ï¼‰

        const textLength = watermarkText.length;
        let fontSize = 0;

        // ä¼˜åŒ–çŸ­æ–‡æœ¬é€»è¾‘ï¼š5ä¸ªåŠä»¥ä¸‹å­—ç¬¦å¼ºåˆ¶å•è¡Œæ˜¾ç¤º
        const maxLines = textLength <= 5 ? 1 : 3;
        const minCharsPerLine = textLength <= 5 ? textLength : 5; // çŸ­æ–‡æœ¬æ¯è¡Œå­—ç¬¦æ•°ç­‰äºæ€»é•¿åº¦
        const SAFETY_FACTOR = textLength <= 5 ? 1.1 : 1.2; // çŸ­æ–‡æœ¬å‡å°‘å®‰å…¨ç³»æ•°ï¼Œè®©å­—ä½“æ›´å¤§
        const PADDING_FACTOR = 0.95; // å¢åŠ å¯ç”¨å®½åº¦å æ¯”

        /*
        // æŒ‰å•è¡Œæœ€å¤§å­—ç¬¦æ•°è®¡ç®—ï¼ˆæ€»é•¿åº¦/æœ€å¤§è¡Œæ•°ï¼‰
        const charsPerLine = Math.ceil(textLength / maxLines);
        fontSize = Math.floor((rectWidth * PADDING_FACTOR) / (charsPerLine * SAFETY_FACTOR));
        */
        
        // è®¡ç®—æ¯è¡Œå­—ç¬¦æ•°ï¼Œç¡®ä¿ä¸å°äºæœ€å°å€¼
        const charsPerLine = Math.max(
            Math.ceil(textLength / maxLines), 
            minCharsPerLine
        );
        
        // å…³é”®ï¼šåŸºäº4/5çš„å®½åº¦è®¡ç®—å­—ä½“å¤§å°ï¼ˆè€Œéå®Œæ•´å®½åº¦ï¼‰
        fontSize = Math.floor((maxWatermarkWidth * PADDING_FACTOR) / (charsPerLine * SAFETY_FACTOR));      

        // è°ƒæ•´å­—ä½“å¤§å°é™åˆ¶ï¼ˆåŸºäº4/5å®½åº¦ï¼‰
        const MAXIMUM_FONT_LIMIT = Math.floor(maxWatermarkWidth / 5); // æœ€å¤§å­—ä½“ä¸è¶…è¿‡4/5å®½åº¦çš„1/5
        fontSize = Math.min(fontSize, MAXIMUM_FONT_LIMIT);
        fontSize = Math.max(fontSize, 14);

        domWatermark.style.fontSize = `${fontSize}px`;
        
        const strokeWidth = Math.max(fontSize / 25, 1.2);
        domWatermark.style.textStroke = `${strokeWidth}px rgba(255, 255, 255, 0.9)`;
        domWatermark.style.webkitTextStroke = `${strokeWidth}px rgba(255, 255, 255, 0.9)`;

        domWatermark.style.display = 'block';
    } else {
        domWatermark.style.display = 'none';
    }
}


                updateRatioButtonState(activeValue, groupName) {
                    this.dom.ratioButtons.forEach(btn => {
                        if (btn.getAttribute('data-group') === groupName) {
                            if (btn.getAttribute('data-value') === String(activeValue)) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        }
                    });
                }

                _setupDragAndDrop() {
                    const dropArea = document.body; 
                    const preventDefaults = (e) => { e.preventDefault(); e.stopPropagation(); };
                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => dropArea.addEventListener(eventName, preventDefaults, false));
                    dropArea.addEventListener('drop', (e) => { this.handleFileUpload(e.dataTransfer.files); }, false);
                }

                async _readFileAsDataURL(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = (e) => reject(new Error('Failed to read file as DataURL.'));
                        reader.readAsDataURL(file);
                    });
                }

                async _loadImageData(file) {
                    try {
                        const dataURL = await this._readFileAsDataURL(file); 
                        
                        const image = await new Promise((resolve, reject) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous'; 
                            img.onload = () => resolve(img);
                            img.onerror = () => reject(new Error('Image load failed from DataURL.'));
                            img.src = dataURL;
                        });
                        
                        const { width, height } = image;
                        
                        if (width <= 0 || height <= 0 || !isFinite(width) || !isFinite(height)) {
                            console.error('Image has invalid dimensions:', file.name, width, 'x', height);
                            throw new Error('Invalid dimensions (0 or NaN)');
                        }
                        
                        return { 
                            id: `${Date.now()}-${Math.random()}`, 
                            src: dataURL, 
                            width, 
                            height, 
                            ratio: width / height, 
                            name: file.name,
                            file: file 
                        };
                    } catch (error) {
                        console.error('Failed to load image metadata:', file.name, error);
                        return null;
                    }
                }

                async handleFileUpload(files) {
                    if (!files || files.length === 0) return;
                    
                    const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                    if (imageFiles.length === 0) { alert('No valid image files detected.'); return; }
                    
                    this.dom.imageContainerParent.classList.remove('hidden');
                    this.dom.emptyState.classList.add('hidden');
                    this.dom.loadingState.classList.remove('hidden');
                    
                    const totalFiles = imageFiles.length;
                    const updateProgress = (loaded, text) => { 
                        this.dom.loadingText.textContent = text; 
                        this.dom.loadingBar.style.width = `${(loaded / totalFiles) * 100}%`; 
                    };

                    updateProgress(0, `æ­£åœ¨åŠ è½½å¹¶è½¬æ¢ ${totalFiles} å¼ å›¾ç‰‡...`);
                    
                    const newImages = [];
                    for (let i = 0; i < totalFiles; i++) {
                        const result = await this._loadImageData(imageFiles[i]);
                        if (result) {
                            newImages.push(result);
                        }
                        updateProgress(i + 1, `å·²è½¬æ¢ ${i + 1}/${totalFiles} å¼ å›¾ç‰‡...`);
                    }
                    
                    this.state.imageItems = this.state.imageItems.concat(newImages); 
                    
                    if (this.state.imageItems.length > 0) {
                        this.dom.loadingState.classList.add('hidden'); 
                                this.state.layoutPositions = [];
        this.state.totalHeight = 0;
                        this.calculateAndRenderRectangle();            
                        this.updateUIState();
                        this._updateWatermarkVisibility();
                    } else {
                        this.dom.loadingState.classList.add('hidden');
                        this.updateUIState();
                        if (files.length > 0) alert('æ‰€æœ‰é€‰å®šçš„å›¾ç‰‡æ–‡ä»¶åŠ è½½å¤±è´¥ã€‚è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚');
                    }
                    this.dom.fileInput.value = '';
                    this.dom.fileInputTop.value = '';
                }

                regenerateLayout() { 
                    if (this.state.imageItems.length === 0) return; 
                    this.state.imageItems.sort(() => 0.5 - Math.random()); 
                    this.calculateAndRenderRectangle(); 
                }

                calculateAndRenderRectangle() {
                    this.state.imageItems = this.state.imageItems.filter(item => 
                        item.ratio > 0 && isFinite(item.ratio)
                    );
                    
                    if (this.state.imageItems.length === 0) { 
                        this.state.layoutPositions = []; this.state.totalHeight = 0; this.updateUIState(); return; 
                    }
                    this.dom.rectContainer.innerHTML = ''; // æ¸…ç©ºåŸæœ‰å†…å®¹

                    // é‡æ–°æ·»åŠ  DOM æ°´å°å±‚
                    this.dom.rectContainer.appendChild(this.dom.domWatermark);
                    
                    const imageContainer = this.dom.imageContainerParent; 
                    const mainContentWidth = imageContainer.getBoundingClientRect().width;
                    const rectContainerPadding = 32; 
                    this.state.rectWidth = Math.round(mainContentWidth - rectContainerPadding);
                    
                    if (this.state.rectWidth < 200) this.state.rectWidth = 200;
                    
                    const [w, h] = this.state.aspectRatio.split(':').map(Number);
            
					// **** æ ¸å¿ƒä¿®æ­£ï¼šä½¿ç”¨å›ºå®šçš„è¡Œæ•°æƒé‡æ¥è®¡ç®—ç†æƒ³è¡Œé«˜ ****
            
					// 1. æ ¹æ®ç›®æ ‡æ¯”ä¾‹è®¡ç®—è¡Œé«˜æƒé‡ï¼š
					const targetRatio = w / h; 
                    
                    
                    const isMobile = window.innerWidth <= 640;
                    const WEIGHTED_ROW_COUNT = isMobile ? 1.5 : 2.0;
                    let idealRowHeight = this.state.rectWidth / (targetRatio * WEIGHTED_ROW_COUNT);
    
                    // ç§»åŠ¨ç«¯å¼ºåˆ¶è¡Œé«˜ä¸è¶…è¿‡å±å¹•é«˜åº¦çš„1/3ï¼Œé¿å…çºµå‘é•¿æ¡
                    if (isMobile) {
                        const maxRowHeight = window.innerHeight / 3; // æœ€å¤§è¡Œé«˜ä¸ºå±å¹•é«˜åº¦çš„1/3
                        idealRowHeight = Math.min(idealRowHeight, maxRowHeight);
                    }
            
					// 3. è®¡ç®—ç†æƒ³è¡Œé«˜ï¼š
					//    idealRowHeight = rectWidth / (ç›®æ ‡æ¯”ä¾‹ * è¡Œæ•°æƒé‡)
					//    è¿™ä¸ªå…¬å¼ç¡®ä¿ idealRowHeight åªç”±å®¹å™¨å®½åº¦å’Œç›®æ ‡æ¯”ä¾‹å†³å®šã€‚
           
					const result = this._findLayoutForTargetHeight(this.state.rectWidth, idealRowHeight);
                    
                    if (!result || !result.positions || typeof result.totalHeight !== 'number' || result.totalHeight === 0) {
                        console.warn("Layout calculation returned invalid results. Aborting render.");
                        this.state.layoutPositions = [];
                        this.state.totalHeight = 0;
                        this.updateUIState();
                        return;
                    }

                    this.state.layoutPositions = result.positions;
                    this.state.totalHeight = result.totalHeight;

                    this.dom.rectContainer.style.width = `${this.state.rectWidth}px`;
                    this.dom.rectContainer.style.height = `${this.state.totalHeight}px`;
                    
                    this._placeImagesInRectangle(this.state.layoutPositions);
                    this.updateUIState();
                    this._updateWatermarkVisibility(); // é‡æ–°è®¡ç®—æ°´å°å¤§å°
                }
                
                _findLayoutForTargetHeight(containerWidth, idealRowHeight) {
                    // å¼ºåˆ¶é‡ç½®ï¼šæ ¹æ®å½“å‰é€‰ä¸­çš„å¸ƒå±€æ¯”ä¾‹ï¼Œé‡æ–°è®¡ç®—ç†æƒ³è¡Œé«˜ï¼ˆä¸å—å›¾ç‰‡æ•°é‡å½±å“ï¼‰
    const [wRatio, hRatio] = this.state.aspectRatio.split(':').map(Number);
    // æ ¸å¿ƒå…¬å¼ï¼šç†æƒ³è¡Œé«˜ = å®¹å™¨å®½åº¦ / (ç›®æ ‡å®½é«˜æ¯” * å›ºå®šåˆ—æ•°æƒé‡)
    // å›ºå®šåˆ—æ•°æƒé‡è®¾ä¸º 4ï¼ˆå¯æ ¹æ®éœ€æ±‚è°ƒæ•´ï¼Œç¡®ä¿1-å¤šå¼ å›¾éƒ½é€‚é…ï¼‰
    const fixedColWeight = 4; 
    idealRowHeight = containerWidth / ((wRatio / hRatio) * fixedColWeight);
                    let low = 20; 
                    let high = containerWidth; 

                    let bestLayout = this._calculateJustifiedLayout(containerWidth, idealRowHeight);
                    
                    if (!bestLayout || bestLayout.totalHeight <= 0 || !isFinite(bestLayout.totalHeight)) {
                         bestLayout = this._calculateJustifiedLayout(containerWidth, this.CONFIG.IDEAL_ROW_HEIGHT);
                         if (!bestLayout || bestLayout.totalHeight <= 0 || !isFinite(bestLayout.totalHeight)) {
                            return { positions: [], totalHeight: 0 };
                         }
                    }
                    
                    let minLayoutDiff = Infinity;
                    if(bestLayout.positions.length > 0) {
                        const rowHeights = bestLayout.positions.reduce((acc, pos) => {
                            if (pos.x === 0) acc.push(pos.height);
                            return acc;
                        }, []);
                        const averageRowHeight = rowHeights.length > 0 ? rowHeights.reduce((sum, h) => sum + h, 0) / rowHeights.length : 0;
                        const diff = Math.abs(averageRowHeight - idealRowHeight);
                        minLayoutDiff = diff;
                    } else {
                        return { positions: [], totalHeight: 0 };
                    }


                    for (let i = 0; i < this.CONFIG.BINARY_SEARCH_ITERATIONS; i++) {
                        const midRowHeight = (low + high) / 2;
                        
                        if (high - low < 0.1) break; 
                        
                        const layout = this._calculateJustifiedLayout(containerWidth, midRowHeight);
                        
                        if (!isFinite(layout.totalHeight) || layout.totalHeight <= 0) {
                            high = midRowHeight; 
                            continue;
                        }

                        const rowHeights = layout.positions.reduce((acc, pos) => {
                            if (pos.x === 0) acc.push(pos.height);
                            return acc;
                        }, []);
                        
                        const averageRowHeight = rowHeights.length > 0 ? rowHeights.reduce((sum, h) => sum + h, 0) / rowHeights.length : 0;
                        const diff = Math.abs(averageRowHeight - idealRowHeight);

                        if (diff < minLayoutDiff) { 
                            minLayoutDiff = diff; 
                            bestLayout = layout; 
                        }
                        
                        if (averageRowHeight < idealRowHeight) { 
                            low = midRowHeight; 
                        } else { 
                            high = midRowHeight; 
                        }
                    }
                    
                    if (!bestLayout || bestLayout.totalHeight <= 0 || !isFinite(bestLayout.totalHeight)) {
                        return { positions: [], totalHeight: 0 };
                    }
                    
                    return bestLayout;
                }
                
_calculateJustifiedLayout(containerWidth, idealHeight) {
    const items = this.state.imageItems;
    if (!items || items.length === 0) return { positions: [], totalHeight: 0 };
    const { GAP } = this.CONFIG;
    const costs = [0], partitions = [0];

    // 1. è®¡ç®—æ¯è¡Œçš„æœ€ä½³åˆ†å‰²ç‚¹ï¼ˆä¸å˜ï¼‰
    for (let i = 1; i <= items.length; i++) {
        let minCost = Infinity, bestPartition = 0;
        for (let j = 1; j <= i; j++) {
            if (costs[j - 1] === Infinity) continue;

            const rowItems = items.slice(j - 1, i);
            const sumOfRatios = rowItems.reduce((sum, item) => sum + item.ratio, 0);
            const gapSpace = (rowItems.length - 1) * GAP;

            // å®¹é”™ï¼šé¿å…é™¤ä»¥0æˆ–æ— æ•ˆå€¼
            if (containerWidth <= gapSpace || sumOfRatios <= 0 || !isFinite(sumOfRatios)) continue;

            const rowHeight = (containerWidth - gapSpace) / sumOfRatios;
            if (!isFinite(rowHeight) || rowHeight <= 0) continue;

            // è®¡ç®—æˆæœ¬ï¼ˆä¸å˜ï¼‰
            const currentCost = Math.pow(Math.abs(rowHeight - idealHeight), 2);
            const totalCost = costs[j - 1] + currentCost;

            if (totalCost < minCost) {
                minCost = totalCost;
                bestPartition = j; // è®°å½•æœ€ä½³åˆ†å‰²ç‚¹
            }
        }
        costs[i] = minCost;
        partitions[i] = bestPartition;
    }

    // 2. ç”Ÿæˆrowsæ—¶ï¼Œå¼ºåˆ¶æ¯è¡Œæœ€å¤š3å¼ å›¾ï¼ˆå·²åŒ…å«ä¿®å¤é€»è¾‘ï¼‰
    const rows = [];
    let currentIndex = items.length;
    const MAX_PER_ROW = 3; // æ¯è¡Œæœ€å¤š3å¼ å›¾ï¼Œè¶…è¿‡åˆ™æ‹†åˆ†

    while (currentIndex > 0) {
        // è®¡ç®—å½“å‰è¡Œçš„èµ·å§‹ç´¢å¼•ï¼ˆä¼˜å…ˆç”¨partitionsçš„æœ€ä½³åˆ†å‰²ç‚¹ï¼‰
        let startIndex = partitions[currentIndex];
        // å®¹é”™1ï¼šå¦‚æœåˆ†å‰²ç‚¹æ— æ•ˆï¼Œå¼ºåˆ¶ä»å½“å‰ä½ç½®å¾€å‰æ¨MAX_PER_ROWå¼ 
        if (startIndex <= 0 || startIndex > currentIndex) {
            startIndex = Math.max(1, currentIndex - MAX_PER_ROW);
        }
        // å®¹é”™2ï¼šç¡®ä¿å½“å‰è¡Œä¸è¶…è¿‡MAX_PER_ROWå¼ 
        if (currentIndex - startIndex + 1 > MAX_PER_ROW) {
            startIndex = currentIndex - MAX_PER_ROW + 1;
        }
        // æ·»åŠ å½“å‰è¡Œ
        rows.unshift(items.slice(startIndex - 1, currentIndex));
        currentIndex = startIndex - 1;
    }

    // 3. ç”Ÿæˆå›¾ç‰‡ä½ç½®ï¼ˆä¸å˜ï¼‰
    const positions = [];
    let currentY = 0;
    for (const rowItems of rows) {
        const sumOfRatios = rowItems.reduce((sum, item) => sum + item.ratio, 0);
        const gapSpace = (rowItems.length - 1) * GAP;
        if (sumOfRatios <= 0) continue;

        const rowHeight = (containerWidth - gapSpace) / sumOfRatios;
        if (!isFinite(rowHeight)) continue;

        let currentX = 0;
        for (const item of rowItems) {
            const itemWidth = rowHeight * item.ratio;
            positions.push({ x: currentX, y: currentY, width: itemWidth, height: rowHeight });
            currentX += itemWidth + GAP;
        }
        currentY += rowHeight + GAP;
    }
    const totalHeight = currentY > 0 ? currentY - GAP : 0;
    return { positions, totalHeight };
}
                
                _placeImagesInRectangle(positions) { 
                    positions.forEach((pos, i) => this._placeSingleImage(i, pos));
                }

_placeSingleImage(index, position) {
    const imageItem = this.state.imageItems[index];
    if (!imageItem || !position) return;

    const item = document.createElement('div');
    item.className = 'rect-item rounded-sm fade-in';
    item.style.cssText = `left: ${position.x}px; top: ${position.y}px; width: ${position.width}px; height: ${position.height}px;`;

    const img = new Image();
    img.src = imageItem.src;
    img.alt = imageItem.name;
    item.appendChild(img);

    // 4. æ–°å¢ï¼šåˆ›å»ºæµ®åŠ¨åˆ é™¤æŒ‰é’®
    const deleteBtn = document.createElement('div');
    deleteBtn.className = 'delete-btn';
    item.appendChild(deleteBtn);

    // 5. ç»‘å®šåˆ é™¤äº‹ä»¶ï¼Œå¤ç”¨ deleteCurrentImage(id)
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ° itemDiv çš„ç‚¹å‡»äº‹ä»¶ (é¿å…æ‰“å¼€æ¨¡æ€æ¡†)
            this.deleteCurrentImage(imageItem.id);
    });

    // 6. ç»‘å®šæ‰“å¼€æ¨¡æ€æ¡†äº‹ä»¶
    item.addEventListener('click', () => this.openModal(index));

    this.dom.rectContainer.appendChild(item);
}

                
                openModal(index) { this.state.currentPreviewIndex = index; this.dom.imageModal.classList.remove('hidden'); document.body.style.overflow = 'hidden'; this.updateModalContent(); }
                closeModal() { this.dom.imageModal.classList.add('hidden'); document.body.style.overflow = ''; }
                switchPreviewImage(direction) { const newIndex = this.state.currentPreviewIndex + direction; if (newIndex >= 0 && newIndex < this.state.imageItems.length) { this.state.currentPreviewIndex = newIndex; this.updateModalContent(); } }
                
                updateModalContent() {
                    const item = this.state.imageItems[this.state.currentPreviewIndex]; if (!item) return;
                    this.dom.modalImage.src = item.src; 
                    this.dom.imageName.textContent = item.name;
                    this.dom.modalImgSize.textContent = `${item.width} Ã— ${item.height}`; 
                    this.dom.modalImgRatio.textContent = item.ratio.toFixed(2);
                    this.dom.currentImageIndex.textContent = this.state.currentPreviewIndex + 1;
                    this.dom.totalImageCount.textContent = this.state.imageItems.length;
                    this.dom.prevImageBtn.disabled = this.state.currentPreviewIndex === 0;
                    this.dom.nextImageBtn.disabled = this.state.imageItems.length === 0 || this.state.currentPreviewIndex === this.state.imageItems.length - 1;
                }
                
                clearAllImages() { 
                    if (confirm('æ‚¨ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å›¾ç‰‡å—ï¼Ÿ')) { 
                        this.state.imageItems = []; 
                        this.dom.rectContainer.innerHTML = ''; 
                        this.dom.rectContainer.appendChild(this.dom.domWatermark); // é‡æ–°æ·»åŠ æ°´å°å±‚
                        this.dom.routeNumberInput.value = '';
                        this.updateUIState();
                        this._updateWatermarkVisibility();
                    } 
                }
                deleteCurrentImage() { 
                    if (confirm('æ‚¨ç¡®å®šè¦åˆ é™¤è¿™å¼ å›¾ç‰‡å—ï¼Ÿ')) { 
                        this.state.imageItems.splice(this.state.currentPreviewIndex, 1); 
                        this.closeModal(); 
                        if (this.state.imageItems.length > 0) { 
                            this.state.currentPreviewIndex = Math.min(this.state.currentPreviewIndex, this.state.imageItems.length - 1); 
                            this.calculateAndRenderRectangle(); 
                        } else { 
                            this.updateUIState(); 
                        } 
                    } 
                }
                downloadSingleImage() { const item = this.state.imageItems[this.state.currentPreviewIndex]; if (!item) return; const a = document.createElement('a'); a.href = item.src; a.download = item.name; document.body.appendChild(a); a.click(); document.body.removeChild(a); }


                _resetDownloadState() {
                    this.state.isDownloading = false;
                    this.dom.downloadBtn.innerHTML = '<i class="fa fa-download"></i> <span>ä¸‹è½½æ‹¼å›¾</span>';
                    this.dom.downloadOverlay.classList.add('hidden');
                    this.dom.downloadOverlay.classList.remove('flex');
                    this.dom.downloadProgressBar.style.width = '0%';
                    this.dom.downloadProgressText.textContent = 'æ­£åœ¨ç­‰å¾…æµè§ˆå™¨æ¸²æŸ“...';
                    this.updateUIState();
                }

                // æ ¸å¿ƒï¼šä½¿ç”¨ html-to-image æˆªå›¾ DOM å…ƒç´ 
                async downloadRectangle() {
                    if (this.state.isDownloading || this.state.imageItems.length === 0) return;
                    const watermarkText = this.dom.routeNumberInput.value.trim();
                    if (watermarkText === '') { this.updateUIState(); return; }

                    this.state.isDownloading = true;
                    this.dom.downloadOverlay.classList.remove('hidden'); this.dom.downloadOverlay.classList.add('flex');
                    this.dom.downloadBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> <span>æ­£åœ¨ç”Ÿæˆ...</span>';
                    
                    const currentScale = getScale();
                    this.dom.downloadOverlay.querySelector('p:first-child').textContent = `æ­£åœ¨ç”Ÿæˆ ${currentScale}å€ å¤§å›¾...`;
                    
                    this.updateUIState();
                    
                    const targetElement = this.dom.rectContainer;
                    
                    // --- æš‚å­˜åŸå§‹æ ·å¼ ---
                    const originalRectShadow = targetElement.style.boxShadow;
                    const originalRectBorder = targetElement.style.border;

                    try {
                        // --- å…³é”®ä¿®å¤ 1: éšè—ä¸‹è½½é®ç½© ---
                        const overlayWasVisible = !this.dom.downloadOverlay.classList.contains('hidden');
                        if(overlayWasVisible) {
                            this.dom.downloadOverlay.style.visibility = 'hidden'; 
                        }

                        // --- å…³é”®ä¿®å¤ 2ï¼šæš‚æ—¶ç§»é™¤å¹²æ‰°æ ·å¼ (ä¿ç•™æ­¤æ­¥éª¤ä»¥é˜²ä¸‡ä¸€) ---
                        targetElement.style.boxShadow = 'none';
                        targetElement.style.border = 'none';
                        
                        await new Promise(resolve => setTimeout(resolve, 50)); 
                        
                        // 3. ä½¿ç”¨ htmlToImage æˆªå›¾
                        const dataUrl = await htmlToImage.toJpeg(targetElement, {
                            quality: this.CONFIG.JPEG_QUALITY, 
                            pixelRatio: currentScale, 
                            backgroundColor: '#ffffff', // å†æ¬¡ç¡¬ç¼–ç èƒŒæ™¯è‰²
                            skipFonts: true, 
                        });


                        // 4. æ¢å¤ DOM æ ·å¼
                        targetElement.style.boxShadow = originalRectShadow;
                        targetElement.style.border = originalRectBorder;

                        // 5. æ¢å¤ä¸‹è½½é®ç½©çš„å¯è§æ€§
                        if(overlayWasVisible) {
                            this.dom.downloadOverlay.style.visibility = 'visible';
                        }
                        
                        // 6. å¯¼å‡º dataUrl (html-to-image ç›´æ¥è¿”å› DataURL)
                        const a = document.createElement('a');
                        a.href = dataUrl;
                        a.download = `${watermarkText}-S${currentScale}x-${Date.now()}.jpeg`; 
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        
                    } catch (error) {
                        console.error('Download Failed:', error);
                        // æ¢å¤æ ·å¼
                        targetElement.style.boxShadow = originalRectShadow;
                        targetElement.style.border = originalRectBorder;

                        alert(`ä¸‹è½½å¤±è´¥: ${error.message}\n\nåŸå› ï¼šå¯èƒ½æ˜¯æµè§ˆå™¨ç¯å¢ƒå…¼å®¹æ€§é—®é¢˜æˆ–å†…å­˜ä¸è¶³ã€‚\nè¯·å°è¯•åœ¨**æ¸…æ™°åº¦**é€‰é¡¹ä¸­åˆ‡æ¢åˆ° **1x (æ™®é€š)** æ¨¡å¼ã€‚`);
                    } finally {
                        this._resetDownloadState();
                    }
                }
                
                updateUIState() {
                    const hasImages = this.state.imageItems.length > 0;
                    const routeNumberEntered = this.dom.routeNumberInput.value.trim() !== '';
                    const inputElement = this.dom.routeNumberInput;
                    
                    this.dom.imageContainerParent.classList.remove('hidden'); 
                    this.dom.emptyState.classList.toggle('hidden', hasImages);
                    this.dom.rectContainer.classList.toggle('hidden', !hasImages);
                    this.dom.statsBar.classList.toggle('hidden', !hasImages);
                    
                    this.dom.regenerateBtn.disabled = !hasImages || this.state.isDownloading;
                    this.dom.downloadBtn.disabled = !hasImages || this.state.isDownloading || !routeNumberEntered;
                    this.dom.clearBtn.disabled = !hasImages || this.state.isDownloading;
                    this.dom.fileInputTopLabel.style.opacity = this.state.isDownloading ? 0.6 : 1;

                    this.dom.rightControls.classList.toggle('hidden', !hasImages && this.dom.statsBar.classList.contains('hidden'));
                    
                    if (hasImages && !routeNumberEntered && !this.state.isDownloading) {
                        inputElement.classList.add('animate-pulse-primary', 'border-error'); 
                    } else {
                        inputElement.classList.remove('animate-pulse-primary', 'border-error');
                    }
                    }
            }

            // --- Initialization ---
            new GalleryOptimizer();
            
            // --- Footer Copyright and Quote Rotator (ä¿æŒä¸å˜) ---
            const START_YEAR = 2024;
            const currentYear = new Date().getFullYear();
            const yearString = currentYear > START_YEAR ? `${START_YEAR}-${currentYear}` : `${START_YEAR}`;
            document.getElementById('copyrightFooter').textContent = `${yearString} | æ·±é«˜åˆ›æ–°â€¢å­¦ç”Ÿä¹‰å·¥æ‹¼å›¾å·¥å…· | itç‹å·¥@2024çº§åˆ›æ–°çº¿é•¿`;
            
function setupQuoteRotator() {
    // å…ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œé¿å…æŠ¥é”™
    const quoteElement = document.getElementById('currentQuote');
    if (!quoteElement) {
        console.warn('è¯­å½•å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    // ç®€åŒ–è¯­å½•æ•°ç»„ï¼Œç¡®ä¿æœ‰å†…å®¹
    const regularQuotes = [
        "å¤©è¡Œå¥ï¼Œå›å­ä»¥è‡ªå¼ºä¸æ¯","ITç‹å·¥æ€è·¯å¦™ï¼Œéš¾é¢˜ä¸€æ¥å…¨è§£æ‰ï¼","ä¸–ä¸Šæ— éš¾äº‹ï¼Œåªæ€•æœ‰å¿ƒäºº", "ç‹å·¥å‡ºå“ï¼Œå¿…å±ç²¾å“"
    ];
    const itPool = ["ITç‹å·¥æŠ€æœ¯å¥½ï¼Œæ’ç­æ•ˆç‡èŠ‚èŠ‚é«˜ï¼"];
    const finalQuotes = [...regularQuotes, ...itPool];
    // ç¡®ä¿æ•°ç»„ä¸ä¸ºç©º
    if (finalQuotes.length === 0) {
        finalQuotes.push("å¥‹æ–—çš„é’æ˜¥æœ€ç¾ä¸½");
    }
    // åˆå§‹æ˜¾ç¤º+å®šæ—¶åˆ‡æ¢
    let currentIndex = 0;
    quoteElement.textContent = finalQuotes[currentIndex];
    setInterval(() => {
        currentIndex = (currentIndex + 1) % finalQuotes.length;
        quoteElement.classList.add('opacity-0');
        setTimeout(() => {
            quoteElement.textContent = finalQuotes[currentIndex];
            quoteElement.classList.remove('opacity-0');
        }, 500);
    }, 5000);
}

            setupQuoteRotator();
        });
    </script>
</body>
</html>